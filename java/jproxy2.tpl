
<<DOCHISTORY>>
/*-------------------------------------------------------------------------------------------------*/
/* Copyright Luminary Solutions Limited                                                            */
/*-------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------*/
/*                                                                                                 */
/* Template:       : jproxy2.tpl                                                                   */
/*                                                                                                 */
/* Template Name   : OpenROAD SCPs Proxy Template                                                  */
/*                                                                                                 */
/* System Name     : ProxyGen                                                                      */
/*                                                                                                 */
/* Sub-System Name : Default Java Templates                                                        */
/*                                                                                                 */
/* Author          : Anthony Simpson (Luminary - An Ingres Company)                                */
/*                                                                                                 */
/* Date            : 02/04/2008                                                                    */
/*                                                                                                 */
/* Description     : Used to generate a proxy wrapper for an OpenROAD class.                       */
/*                                                                                                 */
/* Version History                                                                                 */
/*                                                                                                 */
/* Version Date     Who   Description                                                              */
/* ------- -------- ----- -----------                                                              */
/* 1.0     02/04/08 AGS   Original version.                                                        */
/*-------------------------------------------------------------------------------------------------*/
<<DOCHISTORY>>
/**
 * Copyright ${copyright_holder}
 *
 */
package ${lib_name}.${app_name};

import java.util.*;
import com.ca.openroad.*;
import uk.co.luminary.proxygen.util.*;
<<FOREACHAPP>>
import ${lib_name}.${includedapp}.*;
<<FOREACHAPP>>

 /**
 * <!-- ----------------------------------------------------------------------------------------- -->
 * <pre>
 * Description     : Generated by ProxyGen using template file jproxy2.tpl
 * <!--
 * Interface       : ${lib_name}.${app_name}.${class_prefix}${proxy_class_name}
 * System Name     : ${aka_name}
 * Sub-System Name : ${app_name}
 *
 * Version History
 *
 * Version  Date        Who     Description
 * -------  ----------- -----   -----------
 * 1.0      ${datenow}  ${username}     Original version.
 * </pre>
 * -->
 * @author ProxyGen (jproxy2.tpl)
 * @version Revision $Revision$ created on $Date$ by $Author$
 *
 * <!-- ----------------------------------------------------------------------------------------- -->
 */
public class ${class_prefix}${proxy_class_name}
{
    private ASOSession aso = null;

    public ${class_prefix}${proxy_class_name} (ASOSession aso)
    {
        this.aso = aso;
    }

<<FOREACHSCP>>
<<!NAME=>>(DefineBPM)(CreateASOSession)(DestroyASOSession)(Ping)
<<!GENSCP>>(method)

    /**
     * <!-- ------------------------------------------------------------------------------------- -->
     * <!--
     * Method Name : *L*${scp_name}
     * -->
     * <pre>
     * Description : Calls the ${scp_name} procedure
     *
<<FOREACHPARAM>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<ARRAY>>
<<!DV_NULL>>
    private ArrayList<${class_prefix}*U*${type}> *L*${langname} = new ArrayList<${class_prefix}*U*${type}>();
<<!DV_NULL>>
<<DV_NULL>>
    private ArrayList<${class_prefix}*U*${type}> *L*${langname} = null;
<<DV_NULL>>
<<ARRAY>>
<<CLASS>>
<<!DV_NULL>>
     * @param *L*${langname} ${class_prefix}*U*${type} default system
<<!DV_NULL>>
<<DV_NULL>>
     * @param *L*${langname} ${class_prefix}*U*${type} default null
<<DV_NULL>>
<<CLASS>>
<<SCALAR>>
<<!DV_NULL>>
     * @param *L*${langname} ${type} default ${default_value}
<<!DV_NULL>>
<<DV_NULL>>
     * @param *L*${langname} ${type} default null
<<DV_NULL>>
<<SCALAR>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<FOREACHPARAM>>
     * @throws COMException
     * @throws IllegalArgumentException
     * @throws FatalOSCAException
     * @throws UserOSCAException
     * </pre>
     * <!-- ------------------------------------------------------------------------------------- -->
     */
    public void *L*${scp_name}(HashMap params) throws COMException,
        IllegalArgumentException, FatalOSCAException, UserOSCAException
    {
        ParameterData byref = new ParameterData();

        try
        {
            Collection pset = new ArrayList(params.keySet());

            // Declare Attributes
<<FOREACHPARAM>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
            pset.remove("*L*${langname}");
<<ARRAY>>

            if (params.containsKey("*L*${langname}"))
            {
                byref.declareAttr("${name}", "UCARRAY");
                new ${class_prefix}*U*${type}(null).declareAttributes(byref, "${name}");
            }
<<ARRAY>>
<<CLASS>>

            if (params.containsKey("*L*${langname}"))
            {
                byref.declareAttr("${name}", "USERCLASS");
                new ${class_prefix}*U*${type}(null).declareAttributes(byref, "${name}");
            }
<<CLASS>>
<<SCALAR>>

            if (params.containsKey("*L*${langname}"))
            {
                byref.declareAttr("${name}","${PDOtype}");
            }
<<SCALAR>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<FOREACHPARAM>>

            // Check if the caller passed in a unknown parameter
            if (!pset.isEmpty())
            {
                throw new IllegalArgumentException("Unknown parameter" +
                    (pset.size() > 1 ? "s " : " ") +  Arrays.toString(pset.toArray()));
            }

            // Setup the data.
<<FOREACHPARAM>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<ARRAY>>

            if (params.containsKey("*L*${langname}"))
            {
                if (params.get("*L*${langname}") == null)
                {
                    byref.setNull("${name}");
                }
                else {
                    ArrayList<${class_prefix}*U*${type}> iiarrtmp = (ArrayList<${class_prefix}*U*${type}>)params.get("*L*${langname}");
                    int count = 1;
                    for(${class_prefix}*U*${type} userClass : iiarrtmp)
                    {
                        userClass.setAttributes(byref, "${name}[" + count++ + "]");
                    }
                }
            }
<<ARRAY>>
<<CLASS>>
            if (params.containsKey("*L*${langname}"))
            {
                if (params.get("*L*${langname}") == null)
                {
                    byref.setNull("${name}");
                }
                else
                {
                    ${class_prefix}*U*${type} iiobtmp = (${class_prefix}*U*${type}) params.get("*L*${langname}");
                    iiobtmp.setAttributes(byref, "${name}");
                }
            }
<<CLASS>>
<<SCALAR>>
<<ONLYIF>><<BYTEARRAY>><<STRING>><<FLOAT>><<BYTE>><<DOUBLE>><<SHORT>><<DECIMAL>><<INT>><<MONEY>>
            if (params.containsKey("*L*${langname}"))
            {
                if (params.get("*L*${langname}") == null)
                {
                    byref.setNull("${name}");
                }
                else
                {
                    byref.set${accesstype}("${name}", (${type})params.get("*L*${langname}"));
                }
            }
<<ONLYIF>><<BYTEARRAY>><<STRING>><<FLOAT>><<BYTE>><<DOUBLE>><<SHORT>><<DECIMAL>><<INT>><<MONEY>>
<<ONLYIF>><<DATETIME>>
            if (params.containsKey("*L*${langname}"))
            {
                if (params.get("*L*${langname}") == null)
                {
                    byref.setNull("${name}");
                }
                else
                {
                    if (params.get("*L*${langname}").equals(OpenROADDate.BLANK_DATE))
                    {
                        byref.setBlankDate("${name}");
                    }
                    else
                    {
                        if (OpenROADDateTime.class.isInstance(params.get("*L*${langname}"))
                        {
                            byref.setDate("${name}", (Date)params.get("*L*${langname}"));
                        }
                        else
                        {
                            byref.setDateWithoutTime("${name}", (Date)params.get("*L*${langname}"));
                        }
                    }
                }
            }
<<ONLYIF>><<DATETIME>>
<<SCALAR>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<FOREACHPARAM>>

            // Do the call
<<GENSCP>>(procedure)
            this.aso.callProc("${scp_name}", null, byref);
<<GENSCP>>(procedure)
<<!GENSCP>>
            RemoteServer ro = this.aso.getRSO();
            ro.callProc("${scp_name}", null, byref);
            ro.release();
<<!GENSCP>>
<<FOREACHPARAM>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<ARRAY>>

            if (params.containsKey("*L*${langname}"))
            {
                params.remove("*L*${langname}");

                if (byref.isNull("${name}") == false)
                {
                    ArrayList<${class_prefix}*U*${type}> *L*${langname} = new ArrayList<${class_prefix}*U*${type}>();

                    for(int i=1; i<=byref.lastRow("${name}"); i++)
                    {
                        ${class_prefix}*U*${type} iiobtmp = new ${class_prefix}*U*${type}(this.aso);
                        iiobtmp.populateAttributes(byref, "${name}[" + i + "]");
                        *L*${langname}.add(iiobtmp);
                    }
                    params.put("*L*${langname}", *L*${langname});
                }
                else
                {
                    params.put("*L*${langname}", null);
                }
            }
<<ARRAY>>
<<CLASS>>

            if (params.containsKey("*L*${langname}"))
            {
                params.remove("*L*${langname}");

                if (byref.isNull("${name}") == false)
                {
                  ${class_prefix}*U*${type} ${name} = new ${class_prefix}*U*${type}(this.aso);
                  ${name}.populateAttributes(byref, "${name}");
                  params.put("*L*${langname}", ${name});
                }
                else
                {
                    params.put("*L*${langname}", null);
                }
            }
<<CLASS>>
<<SCALAR>>
<<ONLYIF>><<BYTEARRAY>><<STRING>><<FLOAT>><<BYTE>><<DOUBLE>><<SHORT>><<DECIMAL>><<INT>><<MONEY>>

            if (params.containsKey("*L*${langname}"))
            {
                params.remove("*L*${langname}");

                if (byref.isNull("${name}") == false)
                {
                    params.put("*L*${langname}", byref.get${accesstype}("${name}"));
                }
                else
                {
                    params.put("*L*${langname}", null);
                }
            }
<<ONLYIF>><<BYTEARRAY>><<STRING>><<FLOAT>><<BYTE>><<DOUBLE>><<SHORT>><<DECIMAL>><<INT>><<MONEY>>
<<ONLYIF>><<DATETIME>>

            if (params.containsKey("*L*${langname}"))
            {
                if (byref.isNull("${name}") == false)
                {
                    if (byref.isBlankDate("${name}") == false)
                    {
                        if (byref.isDateWithoutTime("${name}"))
                        {
                            params.put("*L*${langname}", new OpenROADDate(byref.getDate("${name}").getTime()));
                        }
                        else
                        {
                            params.put("*L*${langname}", new OpenROADDateTime(byref.getDate("${name}").getTime()));
                        }
                    }
                    else
                    {
                        params.put("*L*${langname}", OpenROADDate.BLANK_DATE);
                    }
                }
            }
<<ONLYIF>><<DATETIME>>
<<SCALAR>>
<<!NAME=>>(p_so_xmlin)(b_osca)(b_so_xml)(p_arr_UCXML_Include)
<<FOREACHPARAM>>
<<GENSCP>>(procedure)
            switch(this.aso.getOscaErrorType())
            {
                case OSCAError.FATAL_ERROR_TYPE:
                    throw new FatalOSCAException(this.aso.getOscaErrorNo(),
                        this.aso.getOscaMsgTxt());
                case OSCAError.USER_ERROR_TYPE:
                    throw new UserOSCAException(this.aso.getOscaErrorNo(),
                        this.aso.getOscaMsgTxt());
                case OSCAError.INFO_ERROR_TYPE:
                    /*
                     * This is an info error so only needs to be logged.
                     * You should replace this with your own logging code like
                     * log4j.
                     */
                    System.out.println("OSCAError[INFO ONLY]: " +
                        this.aso.getOscaMsgTxt());
                    break;
            }
<<GENSCP>>(procedure)
        }
        finally
        {
            if (byref != null)
            {
                byref.release();
            }
        }
    }
<<!GENSCP>>(method)
<<!NAME=>>(DefineBPM)(CreateASOSession)(DestroyASOSession)(Ping)
<<FOREACHSCP>>
}
